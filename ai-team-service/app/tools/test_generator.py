"""
ChatterFix Test Generator
=========================
Auto-generates pytest test suites for features.

Features:
- Unit tests for Pydantic models
- Integration tests for FastAPI endpoints
- Service layer tests with mocked Firestore
- Fixture generation
- Test data factories
"""

import json
import logging
import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class TestType(Enum):
    """Types of tests to generate"""
    UNIT = "unit"
    INTEGRATION = "integration"
    E2E = "e2e"
    PERFORMANCE = "performance"


@dataclass
class TestCase:
    """Individual test case definition"""
    name: str
    description: str
    test_type: TestType
    setup: List[str] = field(default_factory=list)
    assertions: List[str] = field(default_factory=list)
    teardown: List[str] = field(default_factory=list)
    markers: List[str] = field(default_factory=list)


@dataclass
class TestSuite:
    """Collection of related tests"""
    name: str
    feature_name: str
    tests: List[TestCase] = field(default_factory=list)
    fixtures: List[str] = field(default_factory=list)
    imports: List[str] = field(default_factory=list)


class TestGenerator:
    """
    Generates comprehensive test suites for ChatterFix features.

    Produces:
    - Model validation tests
    - API endpoint tests (CRUD operations)
    - Service layer tests
    - Error handling tests
    - Edge case tests
    - Performance tests
    """

    def __init__(self):
        self.generated_tests: Dict[str, str] = {}

    def _to_snake_case(self, name: str) -> str:
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

    def _to_pascal_case(self, name: str) -> str:
        return ''.join(word.capitalize() for word in self._to_snake_case(name).split('_'))

    def generate_model_tests(
        self,
        feature_name: str,
        fields: List[Dict[str, Any]],
        display_name: Optional[str] = None
    ) -> str:
        """Generate tests for Pydantic models"""

        name = self._to_pascal_case(feature_name)
        snake = self._to_snake_case(feature_name)
        display = display_name or feature_name.replace("_", " ").title()

        # Generate valid test data
        valid_data = {}
        for f in fields:
            valid_data[f["name"]] = self._generate_test_value(f, valid=True)

        # Generate invalid test cases
        invalid_cases = []
        for f in fields:
            if f.get("required", True):
                invalid_cases.append((f["name"], "missing required field"))

        return f'''"""
Tests for {display} Pydantic models
Auto-generated by ChatterFix Test Generator
"""

import pytest
from datetime import datetime
from pydantic import ValidationError

# Import models - adjust path as needed
from app.features.{snake}.models import (
    {name}Base,
    {name}Create,
    {name}Update,
    {name}Response,
    {name}ListResponse,
)


class Test{name}Models:
    """Test suite for {display} models"""

    # Valid test data
    VALID_DATA = {json.dumps(valid_data, indent=8, default=str)}

    # =========================================================================
    # {name}Create Tests
    # =========================================================================

    def test_create_model_with_valid_data(self):
        """Test creating model with valid data"""
        model = {name}Create(**self.VALID_DATA)

        assert model is not None
{self._generate_field_assertions(fields, "model")}

    def test_create_model_validates_required_fields(self):
        """Test that required fields are validated"""
        with pytest.raises(ValidationError) as exc_info:
            {name}Create()  # No data provided

        errors = exc_info.value.errors()
        assert len(errors) > 0

{self._generate_required_field_tests(fields, name)}

    # =========================================================================
    # {name}Update Tests
    # =========================================================================

    def test_update_model_allows_partial_data(self):
        """Test update model accepts partial data"""
        # All fields should be optional in update
        model = {name}Update()
        assert model is not None

    def test_update_model_with_single_field(self):
        """Test updating single field"""
        first_field = list(self.VALID_DATA.keys())[0]
        model = {name}Update(**{{first_field: self.VALID_DATA[first_field]}})
        assert getattr(model, first_field) == self.VALID_DATA[first_field]

    # =========================================================================
    # {name}Response Tests
    # =========================================================================

    def test_response_model_requires_id(self):
        """Test response model requires id field"""
        with pytest.raises(ValidationError):
            {name}Response(**self.VALID_DATA)  # Missing id

    def test_response_model_with_id(self):
        """Test response model with id"""
        data = {{**self.VALID_DATA, "id": "test-id-123"}}
        model = {name}Response(**data)

        assert model.id == "test-id-123"

    def test_response_model_includes_timestamps(self):
        """Test response model handles timestamps"""
        data = {{
            **self.VALID_DATA,
            "id": "test-id-123",
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
        }}
        model = {name}Response(**data)

        assert model.created_at is not None
        assert model.updated_at is not None

    # =========================================================================
    # {name}ListResponse Tests
    # =========================================================================

    def test_list_response_empty(self):
        """Test list response with no items"""
        model = {name}ListResponse(items=[], total=0)

        assert model.items == []
        assert model.total == 0
        assert model.page == 1
        assert model.has_more is False

    def test_list_response_with_items(self):
        """Test list response with items"""
        item = {name}Response(**{{**self.VALID_DATA, "id": "test-1"}})
        model = {name}ListResponse(items=[item], total=1)

        assert len(model.items) == 1
        assert model.total == 1

    def test_list_response_pagination(self):
        """Test list response pagination fields"""
        model = {name}ListResponse(
            items=[],
            total=100,
            page=2,
            page_size=20,
            has_more=True
        )

        assert model.page == 2
        assert model.page_size == 20
        assert model.has_more is True
'''

    def _generate_test_value(self, field: Dict, valid: bool = True) -> Any:
        """Generate a test value for a field"""

        field_type = field.get("type", "str").lower()

        if not valid:
            return None

        values = {
            "str": "test_string",
            "string": "test_string",
            "int": 42,
            "integer": 42,
            "float": 99.99,
            "number": 99.99,
            "bool": True,
            "boolean": True,
            "datetime": "datetime.utcnow()",
            "date": "datetime.utcnow().date()",
            "list": ["item1", "item2"],
            "array": ["item1", "item2"],
            "dict": {"key": "value"},
        }

        if field.get("choices"):
            return field["choices"][0]

        return values.get(field_type, "test_value")

    def _generate_field_assertions(self, fields: List[Dict], var_name: str) -> str:
        """Generate assertions for each field"""

        assertions = []
        for f in fields[:5]:  # First 5 fields
            assertions.append(f'        assert {var_name}.{f["name"]} is not None')
        return "\n".join(assertions)

    def _generate_required_field_tests(self, fields: List[Dict], model_name: str) -> str:
        """Generate tests for each required field"""

        tests = []
        required_fields = [f for f in fields if f.get("required", True)][:3]

        for f in required_fields:
            tests.append(f'''
    def test_create_requires_{f["name"]}(self):
        """Test that {f["name"]} is required"""
        data = {{k: v for k, v in self.VALID_DATA.items() if k != "{f["name"]}"}}

        with pytest.raises(ValidationError) as exc_info:
            {model_name}Create(**data)

        assert any("{f["name"]}" in str(e) for e in exc_info.value.errors())
''')

        return "\n".join(tests)

    def generate_api_tests(
        self,
        feature_name: str,
        fields: List[Dict[str, Any]],
        display_name: Optional[str] = None
    ) -> str:
        """Generate tests for FastAPI endpoints"""

        name = self._to_pascal_case(feature_name)
        snake = self._to_snake_case(feature_name)
        plural = f"{snake}s"
        display = display_name or feature_name.replace("_", " ").title()

        # Generate valid test data
        valid_data = {}
        for f in fields:
            valid_data[f["name"]] = self._generate_test_value(f, valid=True)

        return f'''"""
API tests for {display} endpoints
Auto-generated by ChatterFix Test Generator
"""

import pytest
from datetime import datetime
from fastapi.testclient import TestClient
from unittest.mock import AsyncMock, patch, MagicMock

# Import app - adjust path as needed
from app.main import app


@pytest.fixture
def client():
    """Test client fixture"""
    return TestClient(app)


@pytest.fixture
def valid_{snake}_data():
    """Valid {display} data for testing"""
    return {json.dumps(valid_data, indent=8, default=str)}


@pytest.fixture
def mock_{snake}_service():
    """Mock {display} service"""
    with patch("app.features.{snake}.router.get_service") as mock:
        service = AsyncMock()
        mock.return_value = service
        yield service


class Test{name}API:
    """Test suite for {display} API endpoints"""

    # =========================================================================
    # POST /{plural} - Create
    # =========================================================================

    def test_create_{snake}_success(self, client, valid_{snake}_data, mock_{snake}_service):
        """Test successful creation"""
        mock_{snake}_service.create.return_value = {{
            **valid_{snake}_data,
            "id": "new-id-123",
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
            "is_deleted": False,
        }}

        response = client.post("/api/{plural}", json=valid_{snake}_data)

        assert response.status_code == 201
        data = response.json()
        assert data["id"] == "new-id-123"

    def test_create_{snake}_invalid_data(self, client):
        """Test creation with invalid data"""
        response = client.post("/api/{plural}", json={{}})

        assert response.status_code == 422  # Validation error

    # =========================================================================
    # GET /{plural} - List
    # =========================================================================

    def test_list_{plural}_empty(self, client, mock_{snake}_service):
        """Test listing when empty"""
        mock_{snake}_service.get_all.return_value = {{
            "items": [],
            "total": 0,
            "page": 1,
            "page_size": 20,
            "has_more": False,
        }}

        response = client.get("/api/{plural}")

        assert response.status_code == 200
        data = response.json()
        assert data["items"] == []
        assert data["total"] == 0

    def test_list_{plural}_with_pagination(self, client, mock_{snake}_service):
        """Test listing with pagination"""
        mock_{snake}_service.get_all.return_value = {{
            "items": [],
            "total": 50,
            "page": 2,
            "page_size": 10,
            "has_more": True,
        }}

        response = client.get("/api/{plural}?page=2&page_size=10")

        assert response.status_code == 200
        data = response.json()
        assert data["page"] == 2
        assert data["page_size"] == 10

    # =========================================================================
    # GET /{plural}/{{id}} - Get One
    # =========================================================================

    def test_get_{snake}_success(self, client, valid_{snake}_data, mock_{snake}_service):
        """Test getting single item"""
        mock_{snake}_service.get.return_value = {{
            **valid_{snake}_data,
            "id": "test-id-123",
        }}

        response = client.get("/api/{plural}/test-id-123")

        assert response.status_code == 200
        data = response.json()
        assert data["id"] == "test-id-123"

    def test_get_{snake}_not_found(self, client, mock_{snake}_service):
        """Test getting non-existent item"""
        mock_{snake}_service.get.return_value = None

        response = client.get("/api/{plural}/nonexistent-id")

        assert response.status_code == 404

    # =========================================================================
    # PUT /{plural}/{{id}} - Update
    # =========================================================================

    def test_update_{snake}_success(self, client, valid_{snake}_data, mock_{snake}_service):
        """Test successful update"""
        mock_{snake}_service.update.return_value = {{
            **valid_{snake}_data,
            "id": "test-id-123",
        }}

        response = client.put(
            "/api/{plural}/test-id-123",
            json={{"name": "updated"}} if "name" in valid_{snake}_data else valid_{snake}_data
        )

        assert response.status_code == 200

    def test_update_{snake}_not_found(self, client, mock_{snake}_service):
        """Test updating non-existent item"""
        mock_{snake}_service.update.return_value = None

        response = client.put("/api/{plural}/nonexistent-id", json={{}})

        assert response.status_code == 404

    # =========================================================================
    # DELETE /{plural}/{{id}} - Delete
    # =========================================================================

    def test_delete_{snake}_success(self, client, mock_{snake}_service):
        """Test successful deletion"""
        mock_{snake}_service.delete.return_value = True

        response = client.delete("/api/{plural}/test-id-123")

        assert response.status_code == 204

    def test_delete_{snake}_not_found(self, client, mock_{snake}_service):
        """Test deleting non-existent item"""
        mock_{snake}_service.delete.return_value = False

        response = client.delete("/api/{plural}/nonexistent-id")

        assert response.status_code == 404

    # =========================================================================
    # POST /{plural}/search - Search
    # =========================================================================

    def test_search_{plural}(self, client, mock_{snake}_service):
        """Test search endpoint"""
        mock_{snake}_service.search.return_value = {{
            "items": [],
            "total": 0,
            "page": 1,
            "page_size": 20,
            "has_more": False,
        }}

        response = client.post("/api/{plural}/search", json={{"query": "test"}})

        assert response.status_code == 200
'''

    def generate_service_tests(
        self,
        feature_name: str,
        fields: List[Dict[str, Any]],
        display_name: Optional[str] = None
    ) -> str:
        """Generate tests for service layer"""

        name = self._to_pascal_case(feature_name)
        snake = self._to_snake_case(feature_name)
        display = display_name or feature_name.replace("_", " ").title()

        valid_data = {}
        for f in fields:
            valid_data[f["name"]] = self._generate_test_value(f, valid=True)

        return f'''"""
Service layer tests for {display}
Auto-generated by ChatterFix Test Generator
"""

import pytest
from datetime import datetime
from unittest.mock import AsyncMock, MagicMock, patch

from app.features.{snake}.service import {name}Service


@pytest.fixture
def mock_db():
    """Mock Firestore database"""
    db = MagicMock()
    db.collection.return_value = MagicMock()
    return db


@pytest.fixture
def service(mock_db):
    """Service instance with mocked DB"""
    return {name}Service(mock_db)


@pytest.fixture
def valid_data():
    """Valid test data"""
    return {json.dumps(valid_data, indent=8, default=str)}


class Test{name}Service:
    """Test suite for {display} service"""

    @pytest.mark.asyncio
    async def test_create_adds_timestamps(self, service, valid_data, mock_db):
        """Test that create adds timestamps"""
        mock_doc_ref = MagicMock()
        mock_doc_ref.id = "new-id-123"
        mock_db.collection.return_value.document.return_value = mock_doc_ref
        mock_doc_ref.set = AsyncMock()

        result = await service.create(valid_data)

        assert "created_at" in result or mock_doc_ref.set.called

    @pytest.mark.asyncio
    async def test_get_returns_none_for_missing(self, service, mock_db):
        """Test get returns None for missing document"""
        mock_doc = MagicMock()
        mock_doc.exists = False
        mock_db.collection.return_value.document.return_value.get = AsyncMock(return_value=mock_doc)

        result = await service.get("nonexistent-id")

        assert result is None

    @pytest.mark.asyncio
    async def test_get_excludes_deleted(self, service, mock_db):
        """Test get excludes soft-deleted items"""
        mock_doc = MagicMock()
        mock_doc.exists = True
        mock_doc.to_dict.return_value = {{"is_deleted": True}}
        mock_db.collection.return_value.document.return_value.get = AsyncMock(return_value=mock_doc)

        result = await service.get("deleted-id")

        assert result is None

    @pytest.mark.asyncio
    async def test_delete_soft_by_default(self, service, mock_db):
        """Test delete is soft by default"""
        mock_doc = MagicMock()
        mock_doc.exists = True
        mock_doc_ref = mock_db.collection.return_value.document.return_value
        mock_doc_ref.get = AsyncMock(return_value=mock_doc)
        mock_doc_ref.update = AsyncMock()

        await service.delete("test-id")

        # Should call update with is_deleted, not delete()
        mock_doc_ref.update.assert_called()

    @pytest.mark.asyncio
    async def test_delete_hard_when_specified(self, service, mock_db):
        """Test hard delete when specified"""
        mock_doc = MagicMock()
        mock_doc.exists = True
        mock_doc_ref = mock_db.collection.return_value.document.return_value
        mock_doc_ref.get = AsyncMock(return_value=mock_doc)
        mock_doc_ref.delete = AsyncMock()

        await service.delete("test-id", hard=True)

        mock_doc_ref.delete.assert_called()
'''

    def generate_fixture_file(
        self,
        feature_name: str,
        fields: List[Dict[str, Any]]
    ) -> str:
        """Generate pytest fixtures file"""

        name = self._to_pascal_case(feature_name)
        snake = self._to_snake_case(feature_name)

        valid_data = {}
        for f in fields:
            valid_data[f["name"]] = self._generate_test_value(f)

        return f'''"""
Pytest fixtures for {feature_name.replace("_", " ").title()} tests
Auto-generated by ChatterFix Test Generator
"""

import pytest
from datetime import datetime
from unittest.mock import AsyncMock, MagicMock


@pytest.fixture
def {snake}_data():
    """Sample {feature_name.replace("_", " ")} data"""
    return {json.dumps(valid_data, indent=8, default=str)}


@pytest.fixture
def {snake}_response_data({snake}_data):
    """Sample response data with ID and timestamps"""
    return {{
        **{snake}_data,
        "id": "test-{snake}-001",
        "created_at": datetime.utcnow(),
        "updated_at": datetime.utcnow(),
        "is_deleted": False,
    }}


@pytest.fixture
def {snake}_list_data({snake}_response_data):
    """Sample list of {feature_name.replace("_", " ")} items"""
    return [
        {{**{snake}_response_data, "id": f"test-{snake}-{{i:03d}}"}}
        for i in range(1, 4)
    ]


@pytest.fixture
def mock_{snake}_service():
    """Mocked {feature_name.replace("_", " ")} service"""
    service = AsyncMock()
    service.create = AsyncMock()
    service.get = AsyncMock()
    service.get_all = AsyncMock()
    service.update = AsyncMock()
    service.delete = AsyncMock()
    service.search = AsyncMock()
    return service
'''

    def generate_all_tests(
        self,
        feature_name: str,
        fields: List[Dict[str, Any]],
        display_name: Optional[str] = None
    ) -> Dict[str, str]:
        """Generate complete test suite for a feature"""

        snake = self._to_snake_case(feature_name)

        return {
            f"test_{snake}_models.py": self.generate_model_tests(feature_name, fields, display_name),
            f"test_{snake}_api.py": self.generate_api_tests(feature_name, fields, display_name),
            f"test_{snake}_service.py": self.generate_service_tests(feature_name, fields, display_name),
            f"conftest_{snake}.py": self.generate_fixture_file(feature_name, fields),
        }


def get_test_generator() -> TestGenerator:
    """Get a TestGenerator instance"""
    return TestGenerator()
