"""
Enterprise RBAC User Models
Generated by ChatGPT for ChatterFix CMMS
Production-ready Pydantic models with role-based access control
"""

from typing import Union

from pydantic import BaseModel

# Simple email type for now (avoid email-validator dependency)
EmailStr = str
import logging
from datetime import datetime
from typing import Callable, List, Literal, Optional

from fastapi import Depends, HTTPException, Security, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt

logger = logging.getLogger(__name__)

# JWT Configuration
SECRET_KEY = "chatterfix_super_secret_key_change_in_production_12345"  # TODO: Move to environment
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440  # 24 hours

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")


class UserBase(BaseModel):
    """Base user model with essential information"""

    id: Optional[int] = None
    username: str
    email: EmailStr
    full_name: str
    is_active: bool = True

    class Config:
        from_attributes = True  # For SQLAlchemy compatibility


class UserInDB(UserBase):
    """User model for database storage with password hash and role"""

    password_hash: str
    role: Literal["Technician", "Supervisor", "Auditor", "Admin"]
    created_date: Optional[datetime] = None
    last_login: Optional[datetime] = None

    # Additional enterprise fields
    department: Optional[str] = None
    employee_id: Optional[str] = None
    manager_id: Optional[int] = None


class UserCreate(BaseModel):
    """Model for user creation requests"""

    username: str
    email: EmailStr
    full_name: str
    password: str
    role: Literal["Technician", "Supervisor", "Auditor", "Admin"]
    department: Optional[str] = None
    employee_id: Optional[str] = None


class UserUpdate(BaseModel):
    """Model for user update requests"""

    email: Optional[EmailStr] = None
    full_name: Optional[str] = None
    role: Optional[Literal["Technician", "Supervisor", "Auditor", "Admin"]] = None
    is_active: Optional[bool] = None
    department: Optional[str] = None


class UserResponse(UserBase):
    """Model for user API responses (excludes sensitive data)"""

    role: Literal["Technician", "Supervisor", "Auditor", "Admin"]
    created_date: Optional[datetime] = None
    last_login: Optional[datetime] = None
    department: Optional[str] = None
    employee_id: Optional[str] = None


class Token(BaseModel):
    """JWT token model"""

    access_token: str
    token_type: str = "bearer"
    expires_in: int
    user_id: int
    role: str
    username: str


class TokenData(BaseModel):
    """Token payload data"""

    user_id: Optional[int] = None
    username: Optional[str] = None
    role: Optional[str] = None
    exp: Optional[datetime] = None


# Enterprise Permission Levels
class PermissionLevel:
    """Enterprise permission levels for CMMS operations"""

    # Asset permissions
    ASSET_READ = "asset:read"
    ASSET_WRITE = "asset:write"
    ASSET_DELETE = "asset:delete"

    # Work order permissions
    WORK_ORDER_READ = "work_order:read"
    WORK_ORDER_WRITE = "work_order:write"
    WORK_ORDER_ASSIGN = "work_order:assign"
    WORK_ORDER_DELETE = "work_order:delete"
    WORK_ORDER_APPROVE = "work_order:approve"

    # User management permissions
    USER_READ = "user:read"
    USER_WRITE = "user:write"
    USER_DELETE = "user:delete"
    USER_MANAGE_ROLES = "user:manage_roles"

    # Inventory permissions
    INVENTORY_READ = "inventory:read"
    INVENTORY_WRITE = "inventory:write"
    INVENTORY_PURCHASE = "inventory:purchase"

    # System permissions
    SYSTEM_ADMIN = "system:admin"
    AUDIT_READ = "audit:read"
    REPORT_GENERATE = "report:generate"


# Role-Permission Mapping (Enterprise Standard)
ROLE_PERMISSIONS = {
    "Technician": [
        PermissionLevel.ASSET_READ,
        PermissionLevel.WORK_ORDER_READ,
        PermissionLevel.WORK_ORDER_WRITE,  # Only assigned work orders
        PermissionLevel.INVENTORY_READ,
    ],
    "Supervisor": [
        PermissionLevel.ASSET_READ,
        PermissionLevel.ASSET_WRITE,
        PermissionLevel.WORK_ORDER_READ,
        PermissionLevel.WORK_ORDER_WRITE,
        PermissionLevel.WORK_ORDER_ASSIGN,
        PermissionLevel.WORK_ORDER_APPROVE,
        PermissionLevel.INVENTORY_READ,
        PermissionLevel.INVENTORY_WRITE,
        PermissionLevel.USER_READ,
        PermissionLevel.REPORT_GENERATE,
    ],
    "Auditor": [
        PermissionLevel.ASSET_READ,
        PermissionLevel.WORK_ORDER_READ,
        PermissionLevel.INVENTORY_READ,
        PermissionLevel.USER_READ,
        PermissionLevel.AUDIT_READ,
        PermissionLevel.REPORT_GENERATE,
    ],
    "Admin": [
        # Admins have all permissions
        PermissionLevel.ASSET_READ,
        PermissionLevel.ASSET_WRITE,
        PermissionLevel.ASSET_DELETE,
        PermissionLevel.WORK_ORDER_READ,
        PermissionLevel.WORK_ORDER_WRITE,
        PermissionLevel.WORK_ORDER_ASSIGN,
        PermissionLevel.WORK_ORDER_DELETE,
        PermissionLevel.WORK_ORDER_APPROVE,
        PermissionLevel.USER_READ,
        PermissionLevel.USER_WRITE,
        PermissionLevel.USER_DELETE,
        PermissionLevel.USER_MANAGE_ROLES,
        PermissionLevel.INVENTORY_READ,
        PermissionLevel.INVENTORY_WRITE,
        PermissionLevel.INVENTORY_PURCHASE,
        PermissionLevel.SYSTEM_ADMIN,
        PermissionLevel.AUDIT_READ,
        PermissionLevel.REPORT_GENERATE,
    ],
}


async def get_current_user(token: str = Depends(oauth2_scheme)) -> UserInDB:
    """
    Decode JWT token and return current user
    Enterprise-grade token validation with comprehensive error handling
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        # Decode JWT token
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = payload.get("user_id")
        username: str = payload.get("sub")
        role: str = payload.get("role")

        if user_id is None or username is None or role is None:
            raise credentials_exception

        token_data = TokenData(user_id=user_id, username=username, role=role)

    except JWTError as e:
        logger.warning(f"JWT validation failed: {e}")
        raise credentials_exception

    # In production, this would fetch from database
    # For now, create user object from token data
    user = UserInDB(
        id=token_data.user_id,
        username=token_data.username,
        email=f"{token_data.username}@chatterfix.com",
        full_name=f"User {token_data.username}",
        is_active=True,
        password_hash="",  # Not needed for token validation
        role=token_data.role,
    )

    if user is None:
        raise credentials_exception

    return user


def role_required(allowed_roles: List[str]) -> Callable:
    """
    Enterprise RBAC dependency factory
    Creates a dependency that validates user role against allowed roles

    Args:
        allowed_roles: List of role names that are allowed access

    Returns:
        FastAPI dependency function that validates user role

    Usage:
        @app.get("/admin-only", dependencies=[Depends(role_required(["Admin"]))])
        @app.get("/supervisor-level", dependencies=[Depends(role_required(["Supervisor", "Admin"]))])
    """

    async def check_role(
        current_user: UserInDB = Depends(get_current_user),
    ) -> UserInDB:
        """Validate that current user has required role"""

        if not current_user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="User account is disabled"
            )

        if current_user.role not in allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Access denied. Required roles: {allowed_roles}. User role: {current_user.role}",
            )

        logger.info(
            f"Access granted to user {current_user.username} with role {current_user.role}"
        )
        return current_user

    return check_role


def permission_required(required_permissions: List[str]) -> Callable:
    """
    Advanced permission-based access control
    More granular than role-based, checks specific permissions

    Args:
        required_permissions: List of permission strings required

    Returns:
        FastAPI dependency function that validates permissions
    """

    async def check_permissions(
        current_user: UserInDB = Depends(get_current_user),
    ) -> UserInDB:
        """Validate that current user has required permissions"""

        if not current_user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="User account is disabled"
            )

        # Get user's permissions based on role
        user_permissions = ROLE_PERMISSIONS.get(current_user.role, [])

        # Check if user has all required permissions
        missing_permissions = set(required_permissions) - set(user_permissions)

        if missing_permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Access denied. Missing permissions: {list(missing_permissions)}",
            )

        logger.info(
            f"Permission granted to user {current_user.username} for {required_permissions}"
        )
        return current_user

    return check_permissions


# Convenience dependencies for common role combinations
def admin_required() -> Callable:
    """Require Admin role"""
    return role_required(["Admin"])


def supervisor_or_admin_required() -> Callable:
    """Require Supervisor or Admin role"""
    return role_required(["Supervisor", "Admin"])


def technician_or_above_required() -> Callable:
    """Require Technician, Supervisor, or Admin role"""
    return role_required(["Technician", "Supervisor", "Admin"])


def auditor_access_required() -> Callable:
    """Require Auditor or Admin role (for read-only audit access)"""
    return role_required(["Auditor", "Admin"])
