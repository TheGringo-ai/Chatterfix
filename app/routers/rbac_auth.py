"""
Enterprise RBAC Authentication Router
Generated by Grok AI for ChatterFix CMMS
OAuth2 security scheme with role-based access control
"""

import logging
from datetime import datetime, timedelta
from typing import Annotated, Optional

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

from app.models.permissions import PERMISSION_MATRIX
from app.models.user import (
    Token,
    UserCreate,
    UserInDB,
    UserResponse,
    get_current_user,
)
from app.utils.auth import (
    check_rate_limit,
    create_access_token,
    create_audit_log_entry,
    hash_password,
    session_manager,
    validate_password_strength,
    verify_password,
)

logger = logging.getLogger(__name__)

# OAuth2 Configuration
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")

# Router setup
router = APIRouter(prefix="/auth", tags=["authentication"])


@router.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    """
    Enterprise OAuth2 login endpoint
    Authenticates user and returns JWT access token
    """
    try:
        # Rate limiting check
        rate_allowed, rate_info = check_rate_limit(
            user_id=hash(form_data.username)
            % 10000,  # Simple user ID for rate limiting
            endpoint="auth/token",
            limit=5,  # 5 login attempts
            window_minutes=15,  # per 15 minutes
        )

        if not rate_allowed:
            logger.warning(
                f"Rate limit exceeded for login attempt: {form_data.username}"
            )
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Too many login attempts. Please try again later.",
                headers={"Retry-After": "900"},  # 15 minutes
            )

        # Authenticate user (In production, this would query the database)
        user = await authenticate_user(form_data.username, form_data.password)
        if not user:
            # Create audit log for failed login
            await create_audit_log_entry(
                user_id=0,  # Unknown user
                action="LOGIN_FAILED",
                resource="auth",
                details={
                    "username": form_data.username,
                    "reason": "invalid_credentials",
                    "timestamp": datetime.utcnow().isoformat(),
                },
            )

            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )

        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User account is disabled",
                headers={"WWW-Authenticate": "Bearer"},
            )

        # Create access token
        access_token_expires = timedelta(minutes=1440)  # 24 hours
        token_data = {
            "sub": user.username,
            "user_id": user.id,
            "role": user.role,
            "permissions": PERMISSION_MATRIX.get(user.role, []),
        }

        access_token = create_access_token(
            data=token_data, expires_delta=access_token_expires
        )

        # Create session
        session_id = session_manager.create_session(
            user_id=user.id,
            user_agent=form_data.client_id
            or "",  # OAuth2 doesn't have user_agent, using client_id
            ip_address="unknown",  # Would get from request in real implementation
        )

        # Create audit log for successful login
        await create_audit_log_entry(
            user_id=user.id,
            action="LOGIN_SUCCESS",
            resource="auth",
            details={
                "username": user.username,
                "role": user.role,
                "session_id": session_id,
                "timestamp": datetime.utcnow().isoformat(),
            },
        )

        logger.info(f"Successful login for user {user.username} with role {user.role}")

        return Token(
            access_token=access_token,
            token_type="bearer",
            expires_in=1440 * 60,  # 24 hours in seconds
            user_id=user.id,
            role=user.role,
            username=user.username,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Login error: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Authentication service temporarily unavailable",
        )


@router.post("/register", response_model=UserResponse)
async def register_user(user_data: UserCreate) -> UserResponse:
    """
    Register a new user account
    Includes password strength validation and role assignment
    """
    try:
        # Validate password strength
        is_strong, issues = validate_password_strength(user_data.password)
        if not is_strong:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={
                    "message": "Password does not meet security requirements",
                    "issues": issues,
                },
            )

        # Check if username already exists (In production, check database)
        existing_user = await get_user_by_username(user_data.username)
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already registered",
            )

        # Hash password
        password_hash = hash_password(user_data.password)

        # Create user record (In production, save to database)
        new_user = UserInDB(
            id=generate_user_id(),  # Would auto-increment in real DB
            username=user_data.username,
            email=user_data.email,
            full_name=user_data.full_name,
            password_hash=password_hash,
            role=user_data.role,
            is_active=True,
            created_date=datetime.utcnow(),
            department=user_data.department,
            employee_id=user_data.employee_id,
        )

        # Create audit log for user registration
        await create_audit_log_entry(
            user_id=new_user.id,
            action="USER_REGISTERED",
            resource="user_management",
            details={
                "username": new_user.username,
                "role": new_user.role,
                "department": new_user.department,
                "registered_by": "self",  # Or admin user if applicable
            },
        )

        logger.info(
            f"New user registered: {new_user.username} with role {new_user.role}"
        )

        # Return user response (without password hash)
        return UserResponse(
            id=new_user.id,
            username=new_user.username,
            email=new_user.email,
            full_name=new_user.full_name,
            is_active=new_user.is_active,
            role=new_user.role,
            created_date=new_user.created_date,
            department=new_user.department,
            employee_id=new_user.employee_id,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"User registration error: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="User registration service temporarily unavailable",
        )


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: Annotated[UserInDB, Depends(get_current_user)],
) -> UserResponse:
    """
    Get current user information
    Requires valid JWT token
    """
    return UserResponse(
        id=current_user.id,
        username=current_user.username,
        email=current_user.email,
        full_name=current_user.full_name,
        is_active=current_user.is_active,
        role=current_user.role,
        created_date=current_user.created_date,
        department=current_user.department,
        employee_id=current_user.employee_id,
    )


@router.post("/logout")
async def logout_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    current_user: Annotated[UserInDB, Depends(get_current_user)],
):
    """
    Logout user and revoke token
    Adds token to blacklist and terminates session
    """
    try:
        from app.utils.auth import revoke_token

        # Revoke the token
        success = revoke_token(token)

        if success:
            # Terminate all user sessions (In production, find session by token)
            # For now, just log the logout
            await create_audit_log_entry(
                user_id=current_user.id,
                action="LOGOUT",
                resource="auth",
                details={
                    "username": current_user.username,
                    "logout_time": datetime.utcnow().isoformat(),
                },
            )

            logger.info(f"User {current_user.username} logged out successfully")

            return {"message": "Successfully logged out"}
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, detail="Failed to logout user"
            )

    except Exception as e:
        logger.error(f"Logout error: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Logout service temporarily unavailable",
        )


@router.get("/permissions")
async def get_user_permissions(
    current_user: Annotated[UserInDB, Depends(get_current_user)],
):
    """
    Get current user's permissions and role information
    """
    user_permissions = PERMISSION_MATRIX.get(current_user.role, [])

    return {
        "user_id": current_user.id,
        "username": current_user.username,
        "role": current_user.role,
        "permissions": user_permissions,
        "total_permissions": len(user_permissions),
        "is_admin": current_user.role == "Admin",
        "can_manage_users": "user_management:manage_accounts" in user_permissions,
        "can_approve_work_orders": "work_order:approve" in user_permissions,
    }


@router.get("/roles")
async def get_available_roles(
    current_user: Annotated[UserInDB, Depends(get_current_user)],
):
    """
    Get available roles in the system
    Only admins can see all roles
    """
    if current_user.role != "Admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only administrators can view available roles",
        )

    return {
        "roles": list(PERMISSION_MATRIX.keys()),
        "role_details": {
            role: {"permissions": perms, "permission_count": len(perms)}
            for role, perms in PERMISSION_MATRIX.items()
        },
    }


# Helper functions (In production, these would be in a service layer)


async def authenticate_user(username: str, password: str) -> Optional[UserInDB]:
    """
    Authenticate user credentials
    In production, this would query the database
    """
    # Mock user data for demonstration
    mock_users = {
        "admin": UserInDB(
            id=1,
            username="admin",
            email="admin@chatterfix.com",
            full_name="System Administrator",
            password_hash=hash_password("admin123"),
            role="Admin",
            is_active=True,
            created_date=datetime.utcnow(),
            department="IT",
        ),
        "supervisor": UserInDB(
            id=2,
            username="supervisor",
            email="supervisor@chatterfix.com",
            full_name="Maintenance Supervisor",
            password_hash=hash_password("super123"),
            role="Supervisor",
            is_active=True,
            created_date=datetime.utcnow(),
            department="Maintenance",
        ),
        "technician": UserInDB(
            id=3,
            username="technician",
            email="technician@chatterfix.com",
            full_name="Field Technician",
            password_hash=hash_password("tech123"),
            role="Technician",
            is_active=True,
            created_date=datetime.utcnow(),
            department="Maintenance",
        ),
        "auditor": UserInDB(
            id=4,
            username="auditor",
            email="auditor@chatterfix.com",
            full_name="Compliance Auditor",
            password_hash=hash_password("audit123"),
            role="Auditor",
            is_active=True,
            created_date=datetime.utcnow(),
            department="Compliance",
        ),
    }

    user = mock_users.get(username)
    if user and verify_password(password, user.password_hash):
        return user

    return None


async def get_user_by_username(username: str) -> Optional[UserInDB]:
    """Get user by username (mock implementation)"""
    # In production, query database
    mock_usernames = ["admin", "supervisor", "technician", "auditor"]
    return username.lower() in mock_usernames


def generate_user_id() -> int:
    """Generate user ID (mock implementation)"""
    # In production, this would be auto-increment from database
    import random

    return random.randint(1000, 9999)
