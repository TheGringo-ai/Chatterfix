"""
PM Automation Engine - Advanced Preventive Maintenance Scheduling
Supports time-based, usage-based, condition-based, and predictive maintenance scheduling
"""

import logging
import random
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional

from app.services.advanced_scheduler_service import (
    Priority,
    ScheduleType,
)

logger = logging.getLogger(__name__)


class MaintenanceType(Enum):
    """Types of preventive maintenance"""

    PREVENTIVE = "preventive"
    PREDICTIVE = "predictive"
    CONDITION_BASED = "condition_based"
    USAGE_BASED = "usage_based"
    TIME_BASED = "time_based"
    SEASONAL = "seasonal"
    REGULATORY = "regulatory"


class TriggerType(Enum):
    """Maintenance trigger types"""

    CALENDAR = "calendar"
    RUNTIME_HOURS = "runtime_hours"
    PRODUCTION_CYCLES = "production_cycles"
    VIBRATION_THRESHOLD = "vibration_threshold"
    TEMPERATURE_THRESHOLD = "temperature_threshold"
    PRESSURE_THRESHOLD = "pressure_threshold"
    OIL_ANALYSIS = "oil_analysis"
    WEAR_MEASUREMENT = "wear_measurement"
    SEASONAL_CHANGE = "seasonal_change"
    REGULATORY_DEADLINE = "regulatory_deadline"


@dataclass
class MaintenanceTrigger:
    """Defines when maintenance should be triggered"""

    trigger_type: TriggerType
    threshold_value: float
    warning_threshold: float  # Triggers a warning before maintenance is due
    description: str
    unit: str
    priority_escalation: Priority = Priority.MEDIUM


@dataclass
class MaintenanceTemplate:
    """Template for generating maintenance tasks"""

    template_id: str
    name: str
    description: str
    maintenance_type: MaintenanceType
    triggers: List[MaintenanceTrigger]
    required_skills: List[str]
    estimated_duration: float
    required_parts: List[str] = field(default_factory=list)
    required_tools: List[str] = field(default_factory=list)
    safety_requirements: List[str] = field(default_factory=list)
    procedures: List[str] = field(default_factory=list)
    criticality: int = 3  # 1-5 scale
    can_be_deferred: bool = True
    max_deferral_days: int = 7


@dataclass
class AssetMeter:
    """Tracks asset usage metrics"""

    meter_id: str
    asset_id: str
    meter_type: str  # runtime_hours, cycles, temperature, etc.
    current_value: float
    last_reading_date: datetime
    reading_frequency: int  # days between readings
    unit: str
    is_automated: bool = False  # IoT sensor vs manual reading


@dataclass
class MaintenanceScheduleRule:
    """Rules for generating maintenance schedules"""

    rule_id: str
    asset_id: str
    template_id: str
    schedule_type: ScheduleType
    interval_value: int
    interval_unit: str  # days, hours, cycles, etc.
    start_date: datetime
    end_date: Optional[datetime] = None
    is_active: bool = True
    last_generated: Optional[datetime] = None
    next_due: Optional[datetime] = None
    seasonal_adjustments: Dict[str, float] = field(default_factory=dict)


@dataclass
class GeneratedWorkOrder:
    """Work order generated by PM automation"""

    work_order_id: str
    asset_id: str
    template_id: str
    title: str
    description: str
    priority: Priority
    due_date: datetime
    estimated_duration: float
    required_skills: List[str]
    required_parts: List[str]
    required_tools: List[str]
    generated_date: datetime
    rule_id: str
    trigger_reason: str
    can_be_deferred: bool
    deferral_count: int = 0


class PMAutomationEngine:
    """Advanced PM automation engine with multiple scheduling strategies"""

    def __init__(self):
        self.maintenance_templates: Dict[str, MaintenanceTemplate] = {}
        self.schedule_rules: Dict[str, MaintenanceScheduleRule] = {}
        self.asset_meters: Dict[str, List[AssetMeter]] = {}
        self.generated_work_orders: List[GeneratedWorkOrder] = []
        self.seasonal_factors: Dict[str, Dict[str, float]] = {}

        # Initialize with comprehensive templates and rules
        self._initialize_maintenance_templates()
        self._initialize_schedule_rules()
        self._initialize_asset_meters()
        self._initialize_seasonal_factors()

    def _initialize_maintenance_templates(self):
        """Initialize comprehensive maintenance templates"""

        # Hydraulic Equipment Templates
        self.maintenance_templates["hydraulic_daily"] = MaintenanceTemplate(
            template_id="hydraulic_daily",
            name="Hydraulic System Daily Check",
            description="Daily inspection of hydraulic systems",
            maintenance_type=MaintenanceType.PREVENTIVE,
            triggers=[
                MaintenanceTrigger(
                    trigger_type=TriggerType.CALENDAR,
                    threshold_value=1,
                    warning_threshold=0.8,
                    description="Daily inspection schedule",
                    unit="days",
                    priority_escalation=Priority.LOW,
                )
            ],
            required_skills=["hydraulics", "safety_inspection"],
            estimated_duration=0.5,
            required_tools=["pressure_gauge", "visual_inspection_checklist"],
            safety_requirements=["safety_glasses", "gloves"],
            procedures=[
                "Check hydraulic fluid levels",
                "Inspect for leaks",
                "Check pressure readings",
                "Test emergency stops",
            ],
            criticality=4,
        )

        self.maintenance_templates["hydraulic_monthly"] = MaintenanceTemplate(
            template_id="hydraulic_monthly",
            name="Hydraulic System Monthly Maintenance",
            description="Comprehensive monthly hydraulic maintenance",
            maintenance_type=MaintenanceType.PREVENTIVE,
            triggers=[
                MaintenanceTrigger(
                    trigger_type=TriggerType.CALENDAR,
                    threshold_value=30,
                    warning_threshold=25,
                    description="Monthly maintenance schedule",
                    unit="days",
                ),
                MaintenanceTrigger(
                    trigger_type=TriggerType.RUNTIME_HOURS,
                    threshold_value=720,  # 30 days * 24 hours
                    warning_threshold=600,
                    description="Runtime hours threshold",
                    unit="hours",
                ),
            ],
            required_skills=["hydraulics", "mechanical", "safety_inspection"],
            estimated_duration=4.0,
            required_parts=["hydraulic_filter", "o_rings"],
            required_tools=["pressure_gauge", "torque_wrench", "filter_wrench"],
            safety_requirements=["safety_glasses", "gloves", "lockout_tagout"],
            procedures=[
                "Change hydraulic filters",
                "Test relief valves",
                "Check cylinder seals",
                "Calibrate pressure sensors",
                "Update maintenance records",
            ],
            criticality=5,
        )

        # Electrical Equipment Templates
        self.maintenance_templates["electrical_weekly"] = MaintenanceTemplate(
            template_id="electrical_weekly",
            name="Electrical System Weekly Inspection",
            description="Weekly electrical safety and performance check",
            maintenance_type=MaintenanceType.PREVENTIVE,
            triggers=[
                MaintenanceTrigger(
                    trigger_type=TriggerType.CALENDAR,
                    threshold_value=7,
                    warning_threshold=6,
                    description="Weekly inspection schedule",
                    unit="days",
                )
            ],
            required_skills=["electrical", "safety_inspection"],
            estimated_duration=1.5,
            required_tools=["multimeter", "thermal_camera", "inspection_checklist"],
            safety_requirements=["arc_flash_protection", "insulated_tools"],
            procedures=[
                "Thermal imaging scan",
                "Check electrical connections",
                "Test emergency stops",
                "Verify ground connections",
            ],
            criticality=5,
        )

        # Motor and Drive Templates
        self.maintenance_templates["motor_condition"] = MaintenanceTemplate(
            template_id="motor_condition",
            name="Motor Condition-Based Maintenance",
            description="Condition-based motor maintenance using vibration analysis",
            maintenance_type=MaintenanceType.CONDITION_BASED,
            triggers=[
                MaintenanceTrigger(
                    trigger_type=TriggerType.VIBRATION_THRESHOLD,
                    threshold_value=7.1,  # mm/s RMS
                    warning_threshold=4.5,
                    description="Vibration threshold exceeded",
                    unit="mm/s",
                    priority_escalation=Priority.HIGH,
                ),
                MaintenanceTrigger(
                    trigger_type=TriggerType.TEMPERATURE_THRESHOLD,
                    threshold_value=85,  # Celsius
                    warning_threshold=75,
                    description="Motor temperature threshold",
                    unit="°C",
                    priority_escalation=Priority.URGENT,
                ),
            ],
            required_skills=["motor_repair", "vibration_analysis", "electrical"],
            estimated_duration=6.0,
            required_parts=["motor_bearings", "lubricant"],
            required_tools=["vibration_analyzer", "bearing_puller", "alignment_tools"],
            safety_requirements=["lockout_tagout", "safety_glasses"],
            procedures=[
                "Perform vibration analysis",
                "Check bearing condition",
                "Verify motor alignment",
                "Replace bearings if needed",
                "Update condition monitoring records",
            ],
            criticality=4,
            can_be_deferred=False,
        )

        # Conveyor System Templates
        self.maintenance_templates["conveyor_usage"] = MaintenanceTemplate(
            template_id="conveyor_usage",
            name="Conveyor Usage-Based Maintenance",
            description="Maintenance based on production cycles and runtime",
            maintenance_type=MaintenanceType.USAGE_BASED,
            triggers=[
                MaintenanceTrigger(
                    trigger_type=TriggerType.PRODUCTION_CYCLES,
                    threshold_value=100000,
                    warning_threshold=85000,
                    description="Production cycle threshold",
                    unit="cycles",
                ),
                MaintenanceTrigger(
                    trigger_type=TriggerType.RUNTIME_HOURS,
                    threshold_value=2000,
                    warning_threshold=1800,
                    description="Runtime hours threshold",
                    unit="hours",
                ),
            ],
            required_skills=["conveyor_systems", "mechanical"],
            estimated_duration=3.5,
            required_parts=["conveyor_belt", "drive_chain", "lubricant"],
            required_tools=["belt_tension_gauge", "chain_checker"],
            safety_requirements=["lockout_tagout", "safety_harness"],
            procedures=[
                "Check belt tension and alignment",
                "Inspect drive chain wear",
                "Lubricate drive components",
                "Check safety guards",
            ],
            criticality=3,
        )

        # HVAC Templates
        self.maintenance_templates["hvac_seasonal"] = MaintenanceTemplate(
            template_id="hvac_seasonal",
            name="HVAC Seasonal Maintenance",
            description="Seasonal HVAC system maintenance and tune-up",
            maintenance_type=MaintenanceType.SEASONAL,
            triggers=[
                MaintenanceTrigger(
                    trigger_type=TriggerType.SEASONAL_CHANGE,
                    threshold_value=1,  # Seasons per year
                    warning_threshold=0.9,
                    description="Seasonal maintenance schedule",
                    unit="seasons",
                )
            ],
            required_skills=["hvac", "electrical", "preventive_maintenance"],
            estimated_duration=5.0,
            required_parts=["air_filters", "belts", "refrigerant"],
            required_tools=["manifold_gauges", "belt_tension_gauge"],
            safety_requirements=["safety_glasses", "refrigerant_handling_cert"],
            procedures=[
                "Replace air filters",
                "Check refrigerant levels",
                "Inspect and adjust belts",
                "Calibrate thermostats",
                "Clean condenser coils",
            ],
            criticality=3,
        )

        # Regulatory Compliance Template
        self.maintenance_templates["safety_annual"] = MaintenanceTemplate(
            template_id="safety_annual",
            name="Annual Safety Inspection",
            description="Mandatory annual safety inspection for compliance",
            maintenance_type=MaintenanceType.REGULATORY,
            triggers=[
                MaintenanceTrigger(
                    trigger_type=TriggerType.REGULATORY_DEADLINE,
                    threshold_value=365,
                    warning_threshold=335,  # 30-day warning
                    description="Annual regulatory inspection",
                    unit="days",
                    priority_escalation=Priority.URGENT,
                )
            ],
            required_skills=["safety_inspection", "regulatory_compliance"],
            estimated_duration=8.0,
            required_tools=["inspection_checklist", "measurement_tools"],
            safety_requirements=["certified_inspector"],
            procedures=[
                "Complete regulatory checklist",
                "Document all findings",
                "Test safety systems",
                "Update compliance records",
                "Submit regulatory reports",
            ],
            criticality=5,
            can_be_deferred=False,
        )

    def _initialize_schedule_rules(self):
        """Initialize schedule rules for different asset types"""

        # Hydraulic press rules
        for i in range(1, 9):  # 8 hydraulic presses
            asset_id = f"hydraulic_press_{i:03d}"

            # Daily inspection rule
            self.schedule_rules[f"{asset_id}_daily"] = MaintenanceScheduleRule(
                rule_id=f"{asset_id}_daily",
                asset_id=asset_id,
                template_id="hydraulic_daily",
                schedule_type=ScheduleType.TIME_BASED,
                interval_value=1,
                interval_unit="days",
                start_date=datetime.now(),
                next_due=datetime.now() + timedelta(days=1),
            )

            # Monthly maintenance rule
            self.schedule_rules[f"{asset_id}_monthly"] = MaintenanceScheduleRule(
                rule_id=f"{asset_id}_monthly",
                asset_id=asset_id,
                template_id="hydraulic_monthly",
                schedule_type=ScheduleType.TIME_BASED,
                interval_value=30,
                interval_unit="days",
                start_date=datetime.now(),
                next_due=datetime.now() + timedelta(days=30),
            )

        # CNC machine rules
        for i in range(1, 13):  # 12 CNC machines
            asset_id = f"cnc_machine_{i:03d}"

            self.schedule_rules[f"{asset_id}_electrical"] = MaintenanceScheduleRule(
                rule_id=f"{asset_id}_electrical",
                asset_id=asset_id,
                template_id="electrical_weekly",
                schedule_type=ScheduleType.TIME_BASED,
                interval_value=7,
                interval_unit="days",
                start_date=datetime.now(),
                next_due=datetime.now() + timedelta(days=7),
            )

        # Motor drive condition-based rules
        for i in range(1, 16):  # 15 motor drives
            asset_id = f"motor_drive_{i:03d}"

            self.schedule_rules[f"{asset_id}_condition"] = MaintenanceScheduleRule(
                rule_id=f"{asset_id}_condition",
                asset_id=asset_id,
                template_id="motor_condition",
                schedule_type=ScheduleType.CONDITION_BASED,
                interval_value=0,  # Triggered by conditions, not time
                interval_unit="conditions",
                start_date=datetime.now(),
            )

        # Conveyor system usage-based rules
        for i in range(1, 9):  # 8 conveyor systems
            asset_id = f"conveyor_system_{i:03d}"

            self.schedule_rules[f"{asset_id}_usage"] = MaintenanceScheduleRule(
                rule_id=f"{asset_id}_usage",
                asset_id=asset_id,
                template_id="conveyor_usage",
                schedule_type=ScheduleType.USAGE_BASED,
                interval_value=100000,
                interval_unit="cycles",
                start_date=datetime.now(),
            )

        # HVAC seasonal rules
        for i in range(1, 7):  # 6 HVAC units
            asset_id = f"hvac_unit_{i:03d}"

            self.schedule_rules[f"{asset_id}_seasonal"] = MaintenanceScheduleRule(
                rule_id=f"{asset_id}_seasonal",
                asset_id=asset_id,
                template_id="hvac_seasonal",
                schedule_type=ScheduleType.SEASONAL,
                interval_value=90,  # Quarterly
                interval_unit="days",
                start_date=datetime.now(),
                next_due=datetime.now() + timedelta(days=90),
                seasonal_adjustments={
                    "spring": 1.2,  # 20% more maintenance in spring
                    "summer": 1.5,  # 50% more in summer (high usage)
                    "fall": 1.1,  # 10% more in fall
                    "winter": 0.8,  # 20% less in winter
                },
            )

    def _initialize_asset_meters(self):
        """Initialize asset meters for usage-based maintenance"""
        base_date = datetime.now() - timedelta(days=30)

        # Conveyor system meters
        for i in range(1, 9):
            asset_id = f"conveyor_system_{i:03d}"
            self.asset_meters[asset_id] = [
                AssetMeter(
                    meter_id=f"{asset_id}_cycles",
                    asset_id=asset_id,
                    meter_type="production_cycles",
                    current_value=random.randint(50000, 95000),
                    last_reading_date=base_date,
                    reading_frequency=1,  # Daily readings
                    unit="cycles",
                    is_automated=True,
                ),
                AssetMeter(
                    meter_id=f"{asset_id}_runtime",
                    asset_id=asset_id,
                    meter_type="runtime_hours",
                    current_value=random.randint(1500, 1950),
                    last_reading_date=base_date,
                    reading_frequency=1,
                    unit="hours",
                    is_automated=True,
                ),
            ]

        # Motor drive meters
        for i in range(1, 16):
            asset_id = f"motor_drive_{i:03d}"
            self.asset_meters[asset_id] = [
                AssetMeter(
                    meter_id=f"{asset_id}_vibration",
                    asset_id=asset_id,
                    meter_type="vibration",
                    current_value=random.uniform(2.5, 4.8),
                    last_reading_date=base_date,
                    reading_frequency=1,
                    unit="mm/s",
                    is_automated=True,
                ),
                AssetMeter(
                    meter_id=f"{asset_id}_temperature",
                    asset_id=asset_id,
                    meter_type="temperature",
                    current_value=random.uniform(65, 78),
                    last_reading_date=base_date,
                    reading_frequency=1,
                    unit="°C",
                    is_automated=True,
                ),
            ]

        # Hydraulic system meters
        for i in range(1, 9):
            asset_id = f"hydraulic_press_{i:03d}"
            self.asset_meters[asset_id] = [
                AssetMeter(
                    meter_id=f"{asset_id}_pressure",
                    asset_id=asset_id,
                    meter_type="pressure",
                    current_value=random.uniform(2800, 3200),
                    last_reading_date=base_date,
                    reading_frequency=1,
                    unit="PSI",
                    is_automated=True,
                ),
                AssetMeter(
                    meter_id=f"{asset_id}_cycles",
                    asset_id=asset_id,
                    meter_type="operation_cycles",
                    current_value=random.randint(15000, 28000),
                    last_reading_date=base_date,
                    reading_frequency=1,
                    unit="cycles",
                    is_automated=False,
                ),
            ]

    def _initialize_seasonal_factors(self):
        """Initialize seasonal adjustment factors"""
        self.seasonal_factors = {
            "hvac": {"spring": 1.2, "summer": 1.5, "fall": 1.1, "winter": 0.8},
            "outdoor_equipment": {
                "spring": 1.3,  # Weather changes stress equipment
                "summer": 1.4,  # Heat stress
                "fall": 1.2,  # Prep for winter
                "winter": 0.9,  # Reduced usage
            },
            "production_equipment": {
                "spring": 1.1,
                "summer": 1.0,
                "fall": 1.2,  # High production season
                "winter": 0.9,  # Holiday slowdown
            },
        }

    async def generate_pm_schedule(
        self, start_date: datetime, end_date: datetime
    ) -> List[GeneratedWorkOrder]:
        """Generate PM work orders for the specified period"""
        generated_orders = []

        # Check all schedule rules
        for rule in self.schedule_rules.values():
            if not rule.is_active:
                continue

            orders = await self._generate_orders_for_rule(rule, start_date, end_date)
            generated_orders.extend(orders)

        # Check condition-based triggers
        condition_orders = await self._check_condition_based_triggers(
            start_date, end_date
        )
        generated_orders.extend(condition_orders)

        # Check usage-based triggers
        usage_orders = await self._check_usage_based_triggers(start_date, end_date)
        generated_orders.extend(usage_orders)

        # Apply seasonal adjustments
        self._apply_seasonal_adjustments(generated_orders, start_date, end_date)

        # Store generated orders
        self.generated_work_orders.extend(generated_orders)

        logger.info(
            f"Generated {len(generated_orders)} PM work orders for period {start_date} to {end_date}"
        )

        return generated_orders

    async def _generate_orders_for_rule(
        self, rule: MaintenanceScheduleRule, start_date: datetime, end_date: datetime
    ) -> List[GeneratedWorkOrder]:
        """Generate work orders for a specific schedule rule"""
        orders = []

        if rule.schedule_type in [
            ScheduleType.CONDITION_BASED,
            ScheduleType.USAGE_BASED,
        ]:
            return orders  # These are handled separately

        template = self.maintenance_templates.get(rule.template_id)
        if not template:
            logger.warning(
                f"Template {rule.template_id} not found for rule {rule.rule_id}"
            )
            return orders

        current_date = rule.next_due or start_date

        while current_date <= end_date:
            # Generate work order
            work_order = GeneratedWorkOrder(
                work_order_id=f"PM_{rule.asset_id}_{int(current_date.timestamp())}",
                asset_id=rule.asset_id,
                template_id=rule.template_id,
                title=f"{template.name} - {rule.asset_id.replace('_', ' ').title()}",
                description=template.description,
                priority=self._calculate_priority(template, current_date),
                due_date=current_date,
                estimated_duration=template.estimated_duration,
                required_skills=template.required_skills.copy(),
                required_parts=template.required_parts.copy(),
                required_tools=template.required_tools.copy(),
                generated_date=datetime.now(),
                rule_id=rule.rule_id,
                trigger_reason=f"Scheduled {rule.schedule_type.value} maintenance",
                can_be_deferred=template.can_be_deferred,
            )

            orders.append(work_order)

            # Calculate next due date
            if rule.interval_unit == "days":
                current_date += timedelta(days=rule.interval_value)
            elif rule.interval_unit == "weeks":
                current_date += timedelta(weeks=rule.interval_value)
            elif rule.interval_unit == "months":
                current_date += timedelta(days=rule.interval_value * 30)  # Approximate
            else:
                break  # Unknown interval unit

            # Update rule's next due date
            rule.next_due = current_date
            rule.last_generated = datetime.now()

        return orders

    async def _check_condition_based_triggers(
        self, start_date: datetime, end_date: datetime
    ) -> List[GeneratedWorkOrder]:
        """Check for condition-based maintenance triggers"""
        orders = []

        for asset_id, meters in self.asset_meters.items():
            for meter in meters:
                # Simulate meter reading updates
                await self._simulate_meter_readings(meter)

                # Check if any triggers are exceeded
                triggered_templates = self._check_meter_triggers(meter)

                for template_id in triggered_templates:
                    template = self.maintenance_templates.get(template_id)
                    if not template:
                        continue

                    # Generate condition-based work order
                    work_order = GeneratedWorkOrder(
                        work_order_id=f"CBM_{asset_id}_{int(datetime.now().timestamp())}",
                        asset_id=asset_id,
                        template_id=template_id,
                        title=f"CONDITION ALERT: {template.name} - {asset_id.replace('_', ' ').title()}",
                        description=f"Triggered by {meter.meter_type}: {meter.current_value} {meter.unit}",
                        priority=Priority.HIGH,  # Condition-based is typically higher priority
                        due_date=datetime.now()
                        + timedelta(hours=24),  # Urgent response
                        estimated_duration=template.estimated_duration,
                        required_skills=template.required_skills.copy(),
                        required_parts=template.required_parts.copy(),
                        required_tools=template.required_tools.copy(),
                        generated_date=datetime.now(),
                        rule_id=f"condition_{asset_id}",
                        trigger_reason=f"Condition threshold exceeded: {meter.meter_type} = {meter.current_value} {meter.unit}",
                        can_be_deferred=False,  # Condition-based maintenance shouldn't be deferred
                    )

                    orders.append(work_order)

        return orders

    async def _check_usage_based_triggers(
        self, start_date: datetime, end_date: datetime
    ) -> List[GeneratedWorkOrder]:
        """Check for usage-based maintenance triggers"""
        orders = []

        # Check conveyor systems for usage-based triggers
        for rule in self.schedule_rules.values():
            if rule.schedule_type != ScheduleType.USAGE_BASED:
                continue

            meters = self.asset_meters.get(rule.asset_id, [])
            relevant_meters = [m for m in meters if rule.interval_unit in m.meter_type]

            for meter in relevant_meters:
                if meter.current_value >= rule.interval_value:
                    template = self.maintenance_templates.get(rule.template_id)
                    if not template:
                        continue

                    work_order = GeneratedWorkOrder(
                        work_order_id=f"UBM_{rule.asset_id}_{int(datetime.now().timestamp())}",
                        asset_id=rule.asset_id,
                        template_id=rule.template_id,
                        title=f"USAGE MILESTONE: {template.name} - {rule.asset_id.replace('_', ' ').title()}",
                        description=f"Triggered by {meter.meter_type}: {meter.current_value} {meter.unit}",
                        priority=self._calculate_priority(template, datetime.now()),
                        due_date=datetime.now() + timedelta(days=7),  # Week to schedule
                        estimated_duration=template.estimated_duration,
                        required_skills=template.required_skills.copy(),
                        required_parts=template.required_parts.copy(),
                        required_tools=template.required_tools.copy(),
                        generated_date=datetime.now(),
                        rule_id=rule.rule_id,
                        trigger_reason=f"Usage threshold reached: {meter.current_value} {meter.unit}",
                        can_be_deferred=template.can_be_deferred,
                    )

                    orders.append(work_order)

                    # Reset the meter or update the rule
                    meter.current_value = 0  # Reset cycles/hours counter

        return orders

    async def _simulate_meter_readings(self, meter: AssetMeter):
        """Simulate meter reading updates (would be replaced by real IoT data)"""
        days_since_reading = (datetime.now() - meter.last_reading_date).days

        if days_since_reading >= meter.reading_frequency:
            # Simulate value changes based on meter type
            if meter.meter_type == "vibration":
                # Vibration can increase over time or spike suddenly
                change = random.uniform(-0.2, 0.5)
                meter.current_value = max(0, meter.current_value + change)

            elif meter.meter_type == "temperature":
                # Temperature varies with load and ambient conditions
                change = random.uniform(-3, 5)
                meter.current_value = max(20, meter.current_value + change)

            elif meter.meter_type == "pressure":
                # Pressure can drift or have spikes
                change = random.uniform(-50, 100)
                meter.current_value = max(0, meter.current_value + change)

            elif meter.meter_type in [
                "production_cycles",
                "operation_cycles",
                "runtime_hours",
            ]:
                # Usage meters only increase
                daily_increment = random.uniform(50, 200)  # Cycles per day
                meter.current_value += daily_increment * days_since_reading

            meter.last_reading_date = datetime.now()

    def _check_meter_triggers(self, meter: AssetMeter) -> List[str]:
        """Check if meter readings trigger any maintenance"""
        triggered_templates = []

        # Check condition-based templates
        for template in self.maintenance_templates.values():
            if template.maintenance_type == MaintenanceType.CONDITION_BASED:
                for trigger in template.triggers:
                    if self._meter_matches_trigger(meter, trigger):
                        if meter.current_value >= trigger.threshold_value:
                            triggered_templates.append(template.template_id)

        return triggered_templates

    def _meter_matches_trigger(
        self, meter: AssetMeter, trigger: MaintenanceTrigger
    ) -> bool:
        """Check if a meter matches a maintenance trigger"""
        trigger_meter_map = {
            TriggerType.VIBRATION_THRESHOLD: "vibration",
            TriggerType.TEMPERATURE_THRESHOLD: "temperature",
            TriggerType.PRESSURE_THRESHOLD: "pressure",
            TriggerType.RUNTIME_HOURS: "runtime_hours",
            TriggerType.PRODUCTION_CYCLES: ["production_cycles", "operation_cycles"],
        }

        expected_types = trigger_meter_map.get(trigger.trigger_type, [])
        if isinstance(expected_types, str):
            expected_types = [expected_types]

        return meter.meter_type in expected_types

    def _calculate_priority(
        self, template: MaintenanceTemplate, due_date: datetime
    ) -> Priority:
        """Calculate work order priority based on template and timing"""
        base_priority = Priority.MEDIUM

        if template.maintenance_type == MaintenanceType.REGULATORY:
            base_priority = Priority.URGENT
        elif template.maintenance_type == MaintenanceType.CONDITION_BASED:
            base_priority = Priority.HIGH
        elif template.criticality >= 5:
            base_priority = Priority.HIGH
        elif template.criticality >= 4:
            base_priority = Priority.MEDIUM
        else:
            base_priority = Priority.LOW

        # Escalate priority if overdue
        if due_date < datetime.now():
            days_overdue = (datetime.now() - due_date).days
            if days_overdue > 7:
                return Priority.URGENT
            elif days_overdue > 3:
                return Priority.HIGH
            elif days_overdue > 0:
                return min(Priority.HIGH, Priority(base_priority.value - 1))

        return base_priority

    def _apply_seasonal_adjustments(
        self, orders: List[GeneratedWorkOrder], start_date: datetime, end_date: datetime
    ):
        """Apply seasonal adjustments to maintenance frequency"""
        current_season = self._get_current_season(datetime.now())

        for order in orders:
            # Find applicable seasonal factors
            equipment_type = self._get_equipment_type(order.asset_id)

            if equipment_type in self.seasonal_factors:
                factor = self.seasonal_factors[equipment_type].get(current_season, 1.0)

                # Adjust due date based on seasonal factor
                if factor > 1.0:  # More frequent maintenance
                    days_earlier = int((factor - 1.0) * 7)  # Up to a week earlier
                    order.due_date -= timedelta(days=days_earlier)
                elif factor < 1.0:  # Less frequent maintenance
                    days_later = int((1.0 - factor) * 14)  # Up to two weeks later
                    order.due_date += timedelta(days=days_later)

    def _get_current_season(self, date: datetime) -> str:
        """Determine the current season based on date"""
        month = date.month

        if month in [12, 1, 2]:
            return "winter"
        elif month in [3, 4, 5]:
            return "spring"
        elif month in [6, 7, 8]:
            return "summer"
        else:
            return "fall"

    def _get_equipment_type(self, asset_id: str) -> str:
        """Determine equipment type from asset ID"""
        if "hvac" in asset_id:
            return "hvac"
        elif any(outdoor in asset_id for outdoor in ["forklift", "crane", "generator"]):
            return "outdoor_equipment"
        else:
            return "production_equipment"

    async def get_pm_schedule_overview(self, days_ahead: int = 30) -> Dict[str, Any]:
        """Get comprehensive PM schedule overview"""
        end_date = datetime.now() + timedelta(days=days_ahead)

        # Generate upcoming PM work orders
        upcoming_orders = await self.generate_pm_schedule(datetime.now(), end_date)

        # Categorize by maintenance type
        by_type = {}
        by_priority = {}
        by_asset_type = {}

        for order in upcoming_orders:
            template = self.maintenance_templates.get(order.template_id)
            if template:
                maint_type = template.maintenance_type.value
                by_type[maint_type] = by_type.get(maint_type, 0) + 1

            priority = order.priority.name
            by_priority[priority] = by_priority.get(priority, 0) + 1

            asset_type = self._get_equipment_type(order.asset_id)
            by_asset_type[asset_type] = by_asset_type.get(asset_type, 0) + 1

        # Calculate compliance metrics
        total_templates = len(self.maintenance_templates)
        active_rules = len([r for r in self.schedule_rules.values() if r.is_active])

        return {
            "overview": {
                "total_upcoming_orders": len(upcoming_orders),
                "total_templates": total_templates,
                "active_rules": active_rules,
                "period_days": days_ahead,
            },
            "by_maintenance_type": by_type,
            "by_priority": by_priority,
            "by_asset_type": by_asset_type,
            "upcoming_orders": [
                {
                    "id": order.work_order_id,
                    "title": order.title,
                    "asset_id": order.asset_id,
                    "due_date": order.due_date.isoformat(),
                    "priority": order.priority.name,
                    "estimated_duration": order.estimated_duration,
                    "trigger_reason": order.trigger_reason,
                    "can_be_deferred": order.can_be_deferred,
                }
                for order in upcoming_orders[:20]
            ],  # Limit to first 20 for display
            "templates_summary": [
                {
                    "id": template.template_id,
                    "name": template.name,
                    "type": template.maintenance_type.value,
                    "criticality": template.criticality,
                    "estimated_duration": template.estimated_duration,
                }
                for template in self.maintenance_templates.values()
            ],
        }

    async def update_meter_reading(
        self, meter_id: str, new_value: float
    ) -> Dict[str, Any]:
        """Update a meter reading and check for triggered maintenance"""
        meter = None
        for asset_meters in self.asset_meters.values():
            for m in asset_meters:
                if m.meter_id == meter_id:
                    meter = m
                    break
            if meter:
                break

        if not meter:
            return {"error": "Meter not found"}

        old_value = meter.current_value
        meter.current_value = new_value
        meter.last_reading_date = datetime.now()

        # Check for triggered maintenance
        triggered_templates = self._check_meter_triggers(meter)
        triggered_orders = []

        for template_id in triggered_templates:
            template = self.maintenance_templates.get(template_id)
            if template:
                # Generate immediate work order
                work_order = GeneratedWorkOrder(
                    work_order_id=f"TRIGGER_{meter.asset_id}_{int(datetime.now().timestamp())}",
                    asset_id=meter.asset_id,
                    template_id=template_id,
                    title=f"METER ALERT: {template.name}",
                    description=f"Triggered by {meter.meter_type} reading: {new_value} {meter.unit}",
                    priority=Priority.HIGH,
                    due_date=datetime.now()
                    + timedelta(hours=4),  # 4 hour response time
                    estimated_duration=template.estimated_duration,
                    required_skills=template.required_skills.copy(),
                    required_parts=template.required_parts.copy(),
                    required_tools=template.required_tools.copy(),
                    generated_date=datetime.now(),
                    rule_id=f"meter_trigger_{meter_id}",
                    trigger_reason=f"Meter reading exceeded threshold: {new_value} {meter.unit}",
                    can_be_deferred=False,
                )
                triggered_orders.append(work_order)

        return {
            "meter_id": meter_id,
            "asset_id": meter.asset_id,
            "old_value": old_value,
            "new_value": new_value,
            "unit": meter.unit,
            "triggered_maintenance": len(triggered_orders),
            "work_orders": [
                {
                    "id": wo.work_order_id,
                    "title": wo.title,
                    "priority": wo.priority.name,
                    "due_date": wo.due_date.isoformat(),
                }
                for wo in triggered_orders
            ],
        }


# Global instance
pm_automation_engine = PMAutomationEngine()
